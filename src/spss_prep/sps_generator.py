"""
SPSS syntax (.sps) file generation.
Creates GET DATA, VALUE LABELS, and SAVE OUTFILE blocks.
"""

from typing import Dict, List, Optional
from .utils import format_spss_path, escape_spss_string, sanitize_variable_name, strip_bidi_characters
import logging
import os

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def generate_sps_syntax(
    excel_path: str,
    mappings: Dict[str, Dict[str, int]],
    original_names: Dict[str, str],
    sheet_name: str = 'Sheet1',
    include_save: bool = False,
    save_path: Optional[str] = None,
    use_relative_path: bool = True,
    measure_types: Optional[Dict[str, str]] = None
) -> str:
    """
    Generate complete SPSS syntax file content.
    
    Args:
        excel_path: Path to the encoded Excel file
        mappings: Dictionary of column_name -> {value: code} mappings
        original_names: Dictionary of sanitized_name -> original_name
        sheet_name: Sheet name in Excel file
        include_save: Whether to include SAVE OUTFILE command
        save_path: Path for .sav file (if include_save is True)
        use_relative_path: Use relative path (for downloaded files in same folder)
        measure_types: Dictionary of sanitized_name -> measure type ('ORDINAL', 'NOMINAL', 'SCALE')
        
    Returns:
        Complete SPSS syntax as string
    """
    lines = []
    
    # Header comment
    lines.append("* Auto-generated by SPSS Prep Tool")
    lines.append("* This script imports encoded data and applies value labels")
    lines.append("* Original column names are preserved as variable labels")
    lines.append("*")
    
    if use_relative_path:
        lines.append("* IMPORTANT INSTRUCTIONS:")
        lines.append("* 1. Save both this .sps file and encoded_data.xlsx to the SAME folder")
        lines.append("* 2. Edit the CD command below to point to that folder")
        lines.append("* 3. Run this script in SPSS")
        lines.append("*")
        lines.append("* Example: If you saved files to C:\\Users\\YourName\\Documents\\MySurvey\\")
        lines.append("*          Change the CD command to: CD 'C:\\Users\\YourName\\Documents\\MySurvey'.")
        lines.append("")
        
        # Add CD command to set working directory
        lines.append("* SET THE WORKING DIRECTORY (edit this path!):")
        lines.append("CD 'C:\\Users\\YourName\\Documents'.")
        lines.append("* Change the path above to where you saved the files!")
        lines.append("")
    
    # Determine path to use in GET DATA
    if use_relative_path:
        # Use just the filename (assumes same directory)
        excel_filename = os.path.basename(excel_path)
        file_path_for_spss = excel_filename
    else:
        file_path_for_spss = format_spss_path(excel_path)
    
    # GET DATA block
    # Clean sheet name from bidirectional Unicode characters
    clean_sheet_name = strip_bidi_characters(sheet_name)
    
    lines.append("* Import the data:")
    lines.append("GET DATA")
    lines.append("  /TYPE=XLSX")
    lines.append(f'  /FILE="{file_path_for_spss}"')
    lines.append(f'  /SHEET=name "{clean_sheet_name}"')
    lines.append("  /READNAMES=ON.")
    lines.append("")
    
    # VALUE LABELS block
    if mappings:
        value_labels = generate_value_labels_block(mappings, original_names)
        lines.append(value_labels)
        lines.append("")
    
    # VARIABLE LABELS (show original names if sanitized)
    var_labels = generate_variable_labels_block(original_names)
    if var_labels:
        lines.append(var_labels)
        lines.append("")
    
    # VARIABLE LEVEL (set measure types)
    if measure_types:
        var_level = generate_variable_level_block(measure_types)
        if var_level:
            lines.append(var_level)
            lines.append("")
    
    # SAVE OUTFILE (optional)
    if include_save:
        if not save_path:
            save_path = excel_path.replace('.xlsx', '.sav')
        lines.append(f'SAVE OUTFILE="{format_spss_path(save_path)}".')
        lines.append("")
    
    # Execute
    lines.append("EXECUTE.")
    
    syntax = '\n'.join(lines)
    logger.info("Generated SPSS syntax")
    return syntax


def generate_value_labels_block(
    mappings: Dict[str, Dict[str, int]],
    original_names: Dict[str, str]
) -> str:
    """
    Generate VALUE LABELS block for SPSS syntax.
    
    Args:
        mappings: Dictionary of column_name -> {value: code} mappings
        original_names: Dictionary of sanitized_name -> original_name
        
    Returns:
        VALUE LABELS block as string
    """
    lines = ["VALUE LABELS"]
    
    var_lines = []
    for col_name, mapping in mappings.items():
        # Use sanitized name and strip bidi characters
        sanitized = strip_bidi_characters(sanitize_variable_name(col_name))
        
        # Sort by numeric code
        sorted_items = sorted(mapping.items(), key=lambda x: x[1])
        
        # Build value label pairs
        label_pairs = []
        for value, code in sorted_items:
            escaped_value = escape_spss_string(str(value))
            label_pairs.append(f"{code} '{escaped_value}'")
        
        # Join all pairs for this variable
        var_line = f"  {sanitized} " + ' '.join(label_pairs)
        var_lines.append(var_line)
    
    # Join all variable lines - each needs a slash except the last which gets a period
    if var_lines:
        # Add forward slash after each variable except the last
        for var_line in var_lines[:-1]:
            lines.append(var_line + ' /')
        # Last line gets period
        lines.append(var_lines[-1] + '.')
    
    return '\n'.join(lines)


def generate_variable_labels_block(original_names: Dict[str, str]) -> str:
    """
    Generate VARIABLE LABELS block to preserve original column names.
    
    Args:
        original_names: Dictionary of sanitized_name -> original_name
        
    Returns:
        VARIABLE LABELS block as string, or empty string if not needed
    """
    lines = []
    
    # Only include if names were actually changed
    changed_names = {
        sanitized: original 
        for sanitized, original in original_names.items() 
        if sanitized != original
    }
    
    if not changed_names:
        return ""
    
    lines.append("VARIABLE LABELS")
    
    var_lines = []
    for sanitized, original in changed_names.items():
        # Strip bidi characters from variable name
        clean_var_name = strip_bidi_characters(sanitized)
        escaped_original = escape_spss_string(original)
        var_lines.append(f"  {clean_var_name} '{escaped_original}'")
    
    if var_lines:
        # Add forward slash after each variable except the last
        for var_line in var_lines[:-1]:
            lines.append(var_line + ' /')
        # Last line gets period
        lines.append(var_lines[-1] + '.')
    
    return '\n'.join(lines)


def generate_variable_level_block(measure_types: Dict[str, str]) -> str:
    """
    Generate VARIABLE LEVEL block to set measure types.
    
    Args:
        measure_types: Dictionary of sanitized_name -> measure type
                      ('Ordinal', 'Nominal', 'Scale', or 'Ignore')
        
    Returns:
        VARIABLE LEVEL block as string
    """
    # Group variables by measure type
    by_type = {'ORDINAL': [], 'NOMINAL': [], 'SCALE': []}
    
    for var_name, measure_type in measure_types.items():
        measure_upper = measure_type.upper()
        if measure_upper in by_type and measure_type != 'Ignore':
            # Strip bidi characters from variable name
            clean_var_name = strip_bidi_characters(var_name)
            by_type[measure_upper].append(clean_var_name)
    
    # Generate syntax
    lines = ["VARIABLE LEVEL"]
    type_lines = []
    
    for measure_type in ['ORDINAL', 'NOMINAL', 'SCALE']:
        if by_type[measure_type]:
            vars_str = ' '.join(by_type[measure_type])
            type_lines.append(f"  {vars_str} ({measure_type})")
    
    if not type_lines:
        return ""
    
    # Add forward slash after each line except last
    for line in type_lines[:-1]:
        lines.append(line + ' /')
    # Last line gets period
    lines.append(type_lines[-1] + '.')
    
    return '\n'.join(lines)


def save_sps_file(syntax: str, output_path: str) -> None:
    """
    Save SPSS syntax to .sps file with UTF-8 BOM encoding.
    The BOM is required for SPSS to properly display non-ASCII characters (e.g., Arabic).
    
    Args:
        syntax: SPSS syntax content
        output_path: Path to output .sps file
    """
    with open(output_path, 'w', encoding='utf-8-sig') as f:
        f.write(syntax)
    logger.info(f"Saved SPSS syntax to: {output_path}")


